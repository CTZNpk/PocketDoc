const userModel = require("../models/userModel");
const axios = require("axios");
const Quiz = require("../models/quizModel");
const querystring = require("querystring");
const documentModel = require("../models/documentModel");
const { default: puppeteer } = require("puppeteer");
const { marked } = require("marked");
const archiver = require("archiver");
const path = require("path");
const fs = require("fs");

const generateAndStoreQuiz = async (req, res) => {
  try {
    const requiredFields = ["answerFormats", "startPage", "endPage"];

    const missingFields = requiredFields.filter((field) => !req.body[field]);

    if (missingFields.length > 0) {
      return res.status(400).json({
        status: "error",
        error: `Missing required fields: ${missingFields.join(", ")}`,
      });
    }

    const document = await documentModel.findById(req.body.documentId);
    if (!document) {
      return res.status(404).json({
        status: "error",
        error: `This Document Does not exist`,
      });
    }

    const payload = {
      file_path: document.file,
      start_page: req.body.startPage || 1,
      end_page: req.body.endPage || 1,
      answer_formats: req.body.answerFormats,
      question_type: req.body.questionType || "mixed",
      document_id: document._id,
    };

    const formData = querystring.stringify(payload);

    const fastApiResponse = await axios.post(
      "http://localhost:8000/generate-quiz/",
      formData,
      {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json",
        },
      },
    );

    if (!fastApiResponse.data?.quiz) {
      throw new Error("Invalid quiz response from FastAPI");
    }

    const sortedQuiz = [...fastApiResponse.data.quiz].sort((a, b) => {
      const normalize = (type) =>
        type.toLowerCase().replace("true/false", "true_false");

      const order = {
        mcq: 1,
        true_false: 2,
        short: 3,
        long: 4,
      };

      return order[normalize(a.type)] - order[normalize(b.type)];
    });

    const quizDoc = new Quiz({
      userId: document.userId,
      document: req.body.documentId,
      filePath: document.file,
      startPage: req.body.startPage || 1,
      endPage: req.body.endPage || 1,
      quiz: sortedQuiz,
      metadata: {
        answerFormats: Array.isArray(req.body.answerFormats)
          ? req.body.answerFormats
          : [req.body.answer_formats],
        questionType: req.body.questionType || "mixed",
        generatedAt: new Date(),
      },
      submissions: [],
    });

    await quizDoc.save();

    return res.status(201).json({
      status: "success",
      data: {
        quizId: quizDoc._id,
        questionCount: fastApiResponse.data.quiz.length,
      },
    });
  } catch (error) {
    console.error("Quiz generation failed:", error);
    return res.status(500).json({
      status: "error",
      error: "Quiz generation failed",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

const getUserQuiz = async (req, res) => {
  try {
    const userId = req.user.id;

    const quizzes = await Quiz.find({ userId })
      .populate("document", "title")
      .sort({ createdAt: -1 })
      .exec();

    console.log(quizzes);

    if (!quizzes.length) {
      return res
        .status(404)
        .json({ error: "No quizzes generated by this user" });
    }
    console.log("WE HEHRE");

    const generatedQuizzes = quizzes.map((quiz) => {
      const totalSubmissions = quiz.submissions.length;
      console.log("THIS ALSO WORKS");
      const totalScore = quiz.submissions.reduce(
        (sum, s) => sum + (s.score || 0),
        0,
      );
      const averageScore = totalSubmissions
        ? parseFloat((totalScore / totalSubmissions).toFixed(2))
        : 0;

      return {
        quizId: quiz._id,
        userId: userId,
        documentTitle: quiz.document?.title || "Untitled",
        startPage: quiz.startPage,
        endPage: quiz.endPage,
        totalQuestions: quiz.quiz.length,
        numberOfSubmissions: totalSubmissions,
        averageScore,
      };
    });

    return res.status(200).json({ status: "success", data: generatedQuizzes });
  } catch (error) {
    console.error("Error fetching generated quizzes:", error);
    return res.status(500).json({ error: "Error fetching generated quizzes" });
  }
};

const getQuizById = async (req, res) => {
  const { quizId } = req.params;

  try {
    const quiz = await Quiz.findById(quizId).populate({
      path: "document",
      select: "title", // assuming Document model has a 'title' field
    });

    if (!quiz) {
      return res.status(404).json({ message: "Quiz not found" });
    }

    const numberOfSubmissions = quiz.submissions.length;

    const averageScore =
      numberOfSubmissions === 0
        ? 0
        : quiz.submissions.reduce((sum, s) => sum + (s.score || 0), 0) /
        numberOfSubmissions;

    const responseData = {
      documentTitle: quiz.document?.title || "Untitled",
      startPage: quiz.startPage,
      endPage: quiz.endPage,
      metadata: quiz.metadata,
      numberOfSubmissions,
      averageSubmissionScore: averageScore.toFixed(2),
      questions: quiz.quiz.map((q) => ({
        type: q.type,
        question: q.question,
        options: q.options,
      })),
    };

    res.json(responseData);
  } catch (error) {
    console.error("Error fetching quiz:", error);
    res.status(500).json({ message: "Server error" });
  }
};

const downloadQuizAndKey = async (req, res) => {
  const { quizId } = req.params;

  try {
    const quiz = await Quiz.findById(quizId).populate("document", "title");

    if (!quiz) {
      return res.status(404).json({ message: "Quiz not found" });
    }

    const title = quiz.document?.title?.replace(/\s+/g, "_") || "Untitled";
    const filenameQuiz = `Quiz_${title}_${quiz.startPage}-${quiz.endPage}.pdf`;
    const filenameKey = `Key_${title}_${quiz.startPage}-${quiz.endPage}.pdf`;

    // Markdown for Quiz (with blank lines)
    const quizMarkdown = quiz.quiz
      .map((q, i) => {
        let lines = "";

        if (q.type === "short") lines = "<br/><br/><br/>";
        else if (q.type === "long")
          lines = "<br/><br/><br/><br/><br/><br/><br/>";

        const heading = q.type === "true/false" ? "True / False:" : "_Answer:_";

        return `### Q${i + 1}. ${q.question}\n${q.type === "mcq"
            ? q.options
              .map((opt, j) => `- ${String.fromCharCode(65 + j)}. ${opt}`)
              .join("\n")
            : `${heading} ${lines}`
          }`;
      })
      .join("\n\n");

    // Markdown for Answer Key
    const keyMarkdown = quiz.quiz
      .map((q, i) => `### Q${i + 1}. ${q.question}\n**Answer:** ${q.answer}`)
      .join("\n\n");

    const tempDir = path.join(__dirname, "../temp");
    fs.mkdirSync(tempDir, { recursive: true });

    const quizPath = path.join(tempDir, filenameQuiz);
    const keyPath = path.join(tempDir, filenameKey);

    const browser = await puppeteer.launch();
    const page = await browser.newPage();

    const generatePdf = async (markdownContent, outputPath) => {
      const htmlContent = marked(markdownContent);
      await page.setContent(`
        <html>
          <head>
            <style>
              body {
                font-family: Arial, sans-serif;
                padding: 30px;
                color: #000;
                line-height: 1.6;
              }
              h3 {
                margin-top: 24px;
                font-size: 18px;
              }
              ul {
                margin-top: 8px;
                margin-left: 20px;
              }
              strong {
                color: #333;
              }
            </style>
          </head>
          <body>${htmlContent}</body>
        </html>
      `);
      await page.pdf({ path: outputPath, format: "A4", printBackground: true });
    };

    await generatePdf(quizMarkdown, quizPath);
    await generatePdf(keyMarkdown, keyPath);
    await browser.close();

    // Create ZIP
    const zipName = `QuizFiles_${title}_${quiz.startPage}-${quiz.endPage}.zip`;
    const zipPath = path.join(tempDir, zipName);
    const output = fs.createWriteStream(zipPath);
    const archive = archiver("zip", { zlib: { level: 9 } });

    output.on("close", () => {
      res.download(zipPath, zipName, () => {
        fs.unlink(quizPath, () => { });
        fs.unlink(keyPath, () => { });
        fs.unlink(zipPath, () => { });
      });
    });

    archive.on("error", (err) => {
      throw err;
    });

    archive.pipe(output);
    archive.file(quizPath, { name: filenameQuiz });
    archive.file(keyPath, { name: filenameKey });
    archive.finalize();
  } catch (err) {
    console.error("Error generating quiz/key files:", err);
    res.status(500).json({ message: "Server error" });
  }
};

const submitQuiz = async (req, res) => {
  try {
    const { quizId, userAnswers } = req.body;
    const userId = req.user.id;

    console.log(quizId);
    console.log(userAnswers);

    if (!quizId || !userAnswers || !Array.isArray(userAnswers)) {
      return res.status(400).json({ message: "Missing or invalid input" });
    }

    const quiz = await Quiz.findById(quizId);
    if (!quiz) {
      return res.status(404).json({ message: "Quiz not found" });
    }

    const questions = quiz.quiz.map((q) => q.question);
    const correctAnswers = quiz.quiz.map((q) => q.answer);
    const types = quiz.quiz.map((q) => q.type);

    const payload = new URLSearchParams();

    questions.forEach((q) => payload.append("questions", q));
    correctAnswers.forEach((a) => payload.append("answers", a));
    userAnswers.forEach((ua) => payload.append("user_answers", ua));
    types.forEach((t) => payload.append("types", t));

    const apiResponse = await axios.post(
      "http://localhost:8000/submit-quiz/",
      payload,
      {
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
      },
    );

    const { percentage_score, evaluations, total_score } = apiResponse.data;

    quiz.submissions.push({
      userId,
      score: percentage_score,
      responses: evaluations.map((e, i) => ({
        questionIndex: i,
        userAnswer: userAnswers[i],
        evaluationScore: e.score,
      })),
      submittedAt: new Date(),
    });

    await quiz.save();

    return res.status(200).json({
      message: "Quiz submitted successfully",
      percentage_score,
      total_score,
      evaluation: evaluations,
    });
  } catch (error) {
    console.error("Quiz submission error:", error);
    return res.status(500).json({
      message: "Quiz submission failed",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

module.exports = {
  generateAndStoreQuiz,
  getQuizById,
  downloadQuizAndKey,
  submitQuiz,
  getUserQuiz,
};
